#include <opencv2/opencv.hpp>
#include "WPILib.h"

// Include Pipeline class generated by GRIP
#include "Pipeline.h"

const int counterIterator = 2;

/**
 * Uses IMAQdx to manually acquire a new image each frame, and annotate the image by drawing
 * a circle on it, and show it on the FRC Dashboard.
 */
class IntermediateVisionRobot : public SampleRobot
{
	IMAQdxSession session;
	Image *frame;
	IMAQdxError imaqError;
	bool hassavedframe;
	int robotCounter;
	Pipeline pipeline;

public:
	void RobotInit() override {

		hassavedframe = true;

	    // create an image
		frame = imaqCreateImage(IMAQ_IMAGE_RGB, 0);
		//the camera name (ex "cam0") can be found through the roborio web interface
		imaqError = IMAQdxOpenCamera("cam0", IMAQdxCameraControlModeController, &session);
		if(imaqError != IMAQdxErrorSuccess) {
			DriverStation::ReportError("IMAQdxOpenCamera error: " + std::to_string((long)imaqError) + "\n");
		}
		imaqError = IMAQdxConfigureGrab(session);
		if(imaqError != IMAQdxErrorSuccess) {
			DriverStation::ReportError("IMAQdxConfigureGrab error: " + std::to_string((long)imaqError) + "\n");
		}

		DriverStation::ReportError("Now finished RobotInit Method \n");

		robotCounter = 0;
	}

	void Disabled() override {
		hassavedframe = true;
		IMAQdxStopAcquisition(session);
		robotCounter = 0;
	}

	void OperatorControl() override {

		DriverStation::ReportError("Now in operateControl Method \n");

		// acquire images
		IMAQdxStartAcquisition(session);

        // grab an image, draw the circle, and provide it for the camera server which will
        // in turn send it to the dashboard.
		while(IsOperatorControl() && IsEnabled()) {
			IMAQdxGrab(session, frame, true, NULL);
			if(imaqError != IMAQdxErrorSuccess) {
				DriverStation::ReportError("IMAQdxGrab error: " + std::to_string((long)imaqError) + "\n");
			} else {
				// Process frame
				ImageInfo info;
				imaqGetImageInfo(frame,&info);

//				imaqWriteCustomImageData
//				if (robotCounter%counterIterator)
//				if (true)
//				{
				int type;
				int step;
				switch (info.imageType)
				{
					case IMAQ_IMAGE_U16:
					{
						type = CV_16UC1;
						step = 2*1;
						break;
					}

					case IMAQ_IMAGE_SGL:
					{
						type = CV_32FC1;
						type = 4*1;
						break;
					}

					case IMAQ_IMAGE_COMPLEX:
					{
//						type = CV_8U;
						break;
					}

					case IMAQ_IMAGE_RGB:
					{
						type = CV_8UC4;
						step = 1*4;
						break;
					}

					case IMAQ_IMAGE_HSL:
					{
//						type = CV_8UC4;
						break;
					}

					case IMAQ_IMAGE_RGB_U64:
					{
						type = CV_16UC4;
						step = 2*4;
						break;
					}

					case IMAQ_IMAGE_TYPE_SIZE_GUARD:
					{
//						type = ;
						break;
					}

					case IMAQ_IMAGE_U8:
					{
						type = CV_8UC1;
						step = 1*1;
						break;
					}

					case IMAQ_IMAGE_I16:
					{
						type = CV_16SC1;
						step = 2*1;
						break;
					}
				}

//				if (hassavedframe == true)
//				{
					// Note: cvImage is a complete image including the border.
					// Assume
					cv::Mat cvImage(info.yRes+2*info.border,info.xRes+2*info.border,type,info.imageStart,info.pixelsPerLine*step);

					// Calls Pipeline Class generated by GRIP
					pipeline.setsource0(cvImage);
					pipeline.Process();

					int temp = ((*(pipeline.getfindContoursOutput()))[0][0]).x;
					string tempString = std::to_string(temp);
					cv::putText(cvImage, tempString, cv::Point(50,50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(255,255,0));


					/* These are original code. Works, but runs on main process.
					cv::Mat tempImage;
//					cv::GaussianBlur(cvImage, cvImage, cvSize(5,5), 1.5, 1.5);
		            cv::Laplacian(cvImage, cvImage, -1);
//		            cv::add(cvImage,tempImage,cvImage);
//					cv::Sobel(cvImage,cvImage,-1,2,2);
//		            cv::putText(cvImage, "Hello! This is OpenCV!", cv::Point(50,50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(255,255,0));
//					cv::imwrite("hello.jpg",cvImage);
//					DriverStation::ReportError("Image saved");
//			        hassavedframe = false;
					 */


					CameraServer::GetInstance()->SetImage(frame);

//				}

//		        robotCounter++;
//		        robotCounter = (robotCounter)%counterIterator;
//				imaqDrawShapeOnImage(frame, frame, { 10, 10, 100, 100 }, DrawMode::IMAQ_DRAW_VALUE, ShapeMode::IMAQ_SHAPE_OVAL, 0.0f);

			}
			Wait(0.005);				// wait for a motor update time
		}
        // stop image acquisition
		IMAQdxStopAcquisition(session);
	}
};

START_ROBOT_CLASS(IntermediateVisionRobot)

